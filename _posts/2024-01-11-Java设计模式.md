---
title: Java设计模式
author: mumu
date: 2024-01-11 14:00:00 +0800
categories: [Java,Java设计模式]
tags: [Java,Java设计模式]
pin: false
---

# Java设计模式

## 1 单例模式（Singleton）

### 1.1. 饿汉式

> 类加载到内存后，就实例化一个单例，JVM保证线程安全
> 简单实用，<font color='cornflowerblue' style='background-color:yellow' size=''>推荐使用！</font>
>
> <font color='red' style='background-color:' size=''>唯一缺点：不管用到与否，类装载时就完成实例化</font>
> Class.forName("")
> （话说你不用的，你装载它干啥）

```java
private static final Mgr01 INSTANCE = new Mgr01();
private Mgr01() {};
public static Mgr01 getInstance() {
    return INSTANCE;
}
```

### 1.2. 懒汉式

> 虽然达到了按需初始化的目的，但却带来<font color='red' style='background-color:' size=''>线程不安全</font>的问题

```java
private static Mgr03 INSTANCE;
private Mgr03() {}
public static Mgr03 getInstance() {
    if (INSTANCE == null) 
        INSTANCE = new Mgr03();
    return INSTANCE;
}
```

> <font color='cornflowerblue' style='background-color:' size=''>synchronized</font>修饰方法，但是<font color='red' style='background-color:' size=''>效率会下降</font>

```java
private static Mgr04 INSTANCE;
private Mgr04() {}
public static synchronized Mgr04 getInstance() {
    if (INSTANCE == null) 
        INSTANCE = new Mgr04();
    return INSTANCE;
}
```

> <font color='blue' style='background-color:' size=''>双重检查</font>

```java
private static volatile Mgr06 INSTANCE; 
private Mgr06() {}
public static Mgr06 getInstance() {
    if (INSTANCE == null) {
        synchronized (Mgr06.class) {
            if(INSTANCE == null) 
                INSTANCE = new Mgr06();
        }
    }
    return INSTANCE;
}
```

### 1.3. 其他形式

> 静态内部类

```java
private Mgr07() {}
private static class Mgr07Holder {
    private final static Mgr07 INSTANCE = new Mgr07();
}
public static Mgr07 getInstance() {
    return Mgr07Holder.INSTANCE;
}
```

> 直接使用枚举
>
> 不仅可以解决线程同步，还可以防止反序列化。

```java
public enum Mgr08 {
    INSTANCE;
}
```

## 2 策略模式（Strategy）

